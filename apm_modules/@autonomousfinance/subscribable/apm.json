{
    "TotalInstalls": 4,
    "Versions": [
        {
            "Version": "1.0.0",
            "PkgID": "2ibDAcnUsZHhH9w_2Qef2tjo3-nRLWIbtW_YGuhckho",
            "Installs": 2
        },
        {
            "Version": "1.3.6",
            "PkgID": "zlYN1QIUKEvNH_la7t21kbhN9hFtfd-jBV3IqpOo8WE",
            "Installs": 0
        },
        {
            "Version": "1.3.7",
            "PkgID": "mbLfz8CXhDY6D2tetTm7JkA6UlVnRVOSVwCnb4L6IGk",
            "Installs": 0
        },
        {
            "Version": "1.3.8",
            "PkgID": "x1PE7TlYt2YTc2ldzXdJG_P5Yt2Y-KfKdbe9FIZCEfI",
            "Installs": 2
        }
    ],
    "Repository": "https://github.com/Autonomous-Finance/aos-packages/tree/main/packages/subscribable",
    "Owner": "P6i7xXWuZtuKJVJYNwEqduj0s8R_G4wZJ38TB5Knpy4",
    "Name": "subscribable",
    "Authors": [],
    "Source": "package.loaded[\"pkg-api\"] = nil\npackage.loaded[\"storage-vanilla\"] = nil\npackage.loaded[\"storage-db\"] = nil\ndo\nlocal _ENV = _ENV\npackage.preload[ \"pkg-api\" ] = function( ... ) local arg = _G.arg;\nlocal json = require(\"json\")\nlocal bint = require(\".bint\")(256)\n\nlocal function newmodule(pkg)\n  --[[\n    {\n      topic: string = eventCheckFn: () => boolean\n    }\n  ]]\n  pkg.TopicsAndChecks = pkg.TopicsAndChecks or {}\n\n\n  pkg.PAYMENT_TOKEN = '8p7ApPZxC_37M06QHVejCQrKsHbcJEerd3jWNkDUWPQ'\n  pkg.PAYMENT_TOKEN_TICKER = 'BRKTST'\n\n\n  -- REGISTRATION\n\n  function pkg.registerSubscriber(processId, whitelisted)\n    local subscriberData = pkg._storage.getSubscriber(processId)\n\n    if subscriberData then\n      error('Process ' ..\n        processId ..\n        ' is already registered as a subscriber.')\n    end\n\n    pkg._storage.registerSubscriber(processId, whitelisted)\n\n    ao.send({\n      Target = processId,\n      Action = 'Subscriber-Registration-Confirmation',\n      Whitelisted = tostring(whitelisted),\n      OK = 'true'\n    })\n  end\n\n  function pkg.handleRegisterSubscriber(msg)\n    local processId = msg.From\n\n    pkg.registerSubscriber(processId, false)\n    pkg._subscribeToTopics(msg, processId)\n  end\n\n  function pkg.handleRegisterWhitelistedSubscriber(msg)\n    if msg.From ~= Owner and msg.From ~= ao.id then\n      error('Only the owner or the process itself is allowed to register whitelisted subscribers')\n    end\n\n    local processId = msg.Tags['Subscriber-Process-Id']\n\n    if not processId then\n      error('Subscriber-Process-Id is required')\n    end\n\n    pkg.registerSubscriber(processId, true)\n    pkg._subscribeToTopics(msg, processId)\n  end\n\n  function pkg.handleGetSubscriber(msg)\n    local processId = msg.Tags['Subscriber-Process-Id']\n    local subscriberData = pkg._storage.getSubscriber(processId)\n    ao.send({\n      Target = msg.From,\n      Data = json.encode(subscriberData)\n    })\n  end\n\n  pkg.updateBalance = function(processId, amount, isCredit)\n    local subscriber = pkg._storage.getSubscriber(processId)\n    if not isCredit and not subscriber then\n      error('Subscriber ' .. processId .. ' is not registered. Register first, then make a payment')\n    end\n\n    if not isCredit and bint(subscriber.balance) < bint(amount) then\n      error('Insufficient balance for subscriber ' .. processId .. ' to be debited')\n    end\n\n    pkg._storage.updateBalance(processId, amount, isCredit)\n  end\n\n  function pkg.handleReceivePayment(msg)\n    local processId = msg.Tags[\"X-Subscriber-Process-Id\"]\n\n    local error\n    if not processId then\n      error = \"No subscriber specified\"\n    end\n\n    if msg.From ~= pkg.PAYMENT_TOKEN then\n      error = \"Wrong token. Payment token is \" .. (pkg.PAYMENT_TOKEN or \"?\")\n    end\n\n    if error then\n      ao.send({\n        Target = msg.From,\n        Action = 'Transfer',\n        Recipient = msg.Sender,\n        Quantity = msg.Quantity,\n        [\"X-Action\"] = \"Subscription-Payment-Refund\",\n        [\"X-Details\"] = error\n      })\n\n      ao.send({\n        Target = msg.Sender,\n        [\"Response-For\"] = \"Pay-For-Subscription\",\n        OK = \"false\",\n        Data = error\n      })\n      return\n    end\n\n    pkg.updateBalance(msg.Tags.Sender, msg.Tags.Quantity, true)\n\n    ao.send({\n      Target = msg.Sender,\n      [\"Response-For\"] = \"Pay-For-Subscription\",\n      OK = \"true\"\n    })\n    print('Received subscription payment from ' ..\n      msg.Tags.Sender .. ' of ' .. msg.Tags.Quantity .. ' ' .. msg.From .. \" (\" .. pkg.PAYMENT_TOKEN_TICKER .. \")\")\n  end\n\n  function pkg.handleSetPaymentToken(msg)\n    pkg.PAYMENT_TOKEN = msg.Tags.Token\n  end\n\n  -- TOPICS\n\n  function pkg.configTopicsAndChecks(cfg)\n    pkg.TopicsAndChecks = cfg\n  end\n\n  function pkg.getTopicsInfo()\n    local topicsInfo = {}\n    for topic, _ in pairs(pkg.TopicsAndChecks) do\n      local topicInfo = pkg.TopicsAndChecks[topic]\n      topicsInfo[topic] = {\n        description = topicInfo.description,\n        returns = topicInfo.returns,\n        subscriptionBasis = topicInfo.subscriptionBasis\n      }\n    end\n\n    return topicsInfo\n  end\n\n  function pkg.getInfo()\n    return {\n      paymentTokenTicker = pkg.PAYMENT_TOKEN_TICKER,\n      paymentToken = pkg.PAYMENT_TOKEN,\n      topics = pkg.getTopicsInfo()\n    }\n  end\n\n  -- SUBSCRIPTIONS\n\n  function pkg._subscribeToTopics(msg, processId)\n    assert(msg.Tags['Topics'], 'Topics is required')\n\n    local topics = json.decode(msg.Tags['Topics'])\n\n    pkg.onlyRegisteredSubscriber(processId)\n\n    pkg._storage.subscribeToTopics(processId, topics)\n\n    local subscriber = pkg._storage.getSubscriber(processId)\n\n    ao.send({\n      Target = processId,\n      ['Response-For'] = 'Subscribe-To-Topics',\n      OK = \"true\",\n      [\"Updated-Topics\"] = json.encode(subscriber.topics)\n    })\n  end\n\n  -- same for regular and whitelisted subscriptions - the subscriber must call it\n  function pkg.handleSubscribeToTopics(msg)\n    local processId = msg.From\n    pkg._subscribeToTopics(msg, processId)\n  end\n\n  function pkg.unsubscribeFromTopics(processId, topics)\n    pkg.onlyRegisteredSubscriber(processId)\n\n    pkg._storage.unsubscribeFromTopics(processId, topics)\n\n    local subscriber = pkg._storage.getSubscriber(processId)\n\n    ao.send({\n      Target = processId,\n      [\"Response-For\"] = 'Unsubscribe-From-Topics',\n      OK = \"true\",\n      [\"Updated-Topics\"] = json.encode(subscriber.topics)\n    })\n  end\n\n  function pkg.handleUnsubscribeFromTopics(msg)\n    assert(msg.Tags['Topics'], 'Topics is required')\n\n    local processId = msg.From\n    local topics = msg.Tags['Topics']\n\n    pkg.unsubscribeFromTopics(processId, topics)\n  end\n\n  -- NOTIFICATIONS\n\n  -- core dispatch functionality\n\n  function pkg.notifySubscribers(topic, payload)\n    local targets = pkg._storage.getTargetsForTopic(topic)\n    for _, target in ipairs(targets) do\n      ao.send({\n        Target = target,\n        Action = 'Notify-On-Topic',\n        Topic = topic,\n        Data = json.encode(payload)\n      })\n    end\n  end\n\n  -- notify without check\n\n  function pkg.notifyTopics(topicsAndPayloads, timestamp)\n    for topic, payload in pairs(topicsAndPayloads) do\n      payload.timestamp = timestamp\n      pkg.notifySubscribers(topic, payload)\n    end\n  end\n\n  function pkg.notifyTopic(topic, payload, timestamp)\n    return pkg.notifyTopics({\n      [topic] = payload\n    }, timestamp)\n  end\n\n  -- notify with configured checks\n\n  function pkg.checkNotifyTopics(topics, timestamp)\n    for _, topic in ipairs(topics) do\n      local shouldNotify = pkg.TopicsAndChecks[topic].checkFn()\n      if shouldNotify then\n        local payload = pkg.TopicsAndChecks[topic].payloadFn()\n        payload.timestamp = timestamp\n        pkg.notifySubscribers(topic, payload)\n      end\n    end\n  end\n\n  function pkg.checkNotifyTopic(topic, timestamp)\n    return pkg.checkNotifyTopics({ topic }, timestamp)\n  end\n\n  -- HELPERS\n\n  pkg.onlyRegisteredSubscriber = function(processId)\n    local subscriberData = pkg._storage.getSubscriber(processId)\n    if not subscriberData then\n      error('process ' .. processId .. ' is not registered as a subscriber')\n    end\n  end\nend\n\nreturn newmodule\nend\nend\n\ndo\nlocal _ENV = _ENV\npackage.preload[ \"storage-db\" ] = function( ... ) local arg = _G.arg;\nlocal sqlite3 = require(\"lsqlite3\")\nlocal bint = require(\".bint\")(256)\nlocal json = require(\"json\")\n\nlocal function newmodule(pkg)\n  local mod = {}\n  pkg._storage = mod\n\n  local sql = {}\n\n  DB = DB or sqlite3.open_memory()\n\n  sql.create_subscribers_table = [[\n    CREATE TABLE IF NOT EXISTS subscribers (\n        process_id TEXT PRIMARY KEY,\n        topics TEXT,  -- treated as JSON (an array of strings)\n        balance TEXT,\n        whitelisted INTEGER NOT NULL, -- 0 or 1 (false or true)\n    );\n  ]]\n\n  local function createTableIfNotExists()\n    DB:exec(sql.create_subscribers_table)\n    print(\"Err: \" .. DB:errmsg())\n  end\n\n  createTableIfNotExists()\n\n  -- REGISTRATION & BALANCES\n\n  ---@param whitelisted boolean\n  function mod.registerSubscriber(processId, whitelisted)\n    local stmt = DB:prepare [[\n    INSERT INTO subscribers (process_id, balance, whitelisted)\n    VALUES (:process_id, :balance, :whitelisted)\n  ]]\n    if not stmt then\n      error(\"Failed to prepare SQL statement for registering process: \" .. DB:errmsg())\n    end\n    stmt:bind_names({\n      process_id = processId,\n      balance = \"0\",\n      whitelisted = whitelisted and 1 or 0\n    })\n    local _, err = stmt:step()\n    stmt:finalize()\n    if err then\n      error(\"Err: \" .. DB:errmsg())\n    end\n  end\n\n  function mod.getSubscriber(processId)\n    local stmt = DB:prepare [[\n    SELECT * FROM subscribers WHERE process_id = :process_id\n  ]]\n    if not stmt then\n      error(\"Failed to prepare SQL statement for checking subscriber: \" .. DB:errmsg())\n    end\n    stmt:bind_names({ process_id = processId })\n    local result = sql.queryOne(stmt)\n    if result then\n      result.whitelisted = result.whitelisted == 1\n      result.topics = json.decode(result.topics)\n    end\n    return result\n  end\n\n  function sql.updateBalance(processId, amount, isCredit)\n    local currentBalance = bint(sql.getBalance(processId))\n    local diff = isCredit and bint(amount) or -bint(amount)\n    local newBalance = tostring(currentBalance + diff)\n\n    local stmt = DB:prepare [[\n    UPDATE subscribers\n    SET balance = :new_balance\n    WHERE process_id = :process_id\n  ]]\n    if not stmt then\n      error(\"Failed to prepare SQL statement for updating balance: \" .. DB:errmsg())\n    end\n    stmt:bind_names({\n      process_id = processId,\n      new_balance = newBalance,\n    })\n    local result, err = stmt:step()\n    stmt:finalize()\n    if err then\n      error(\"Error updating balance: \" .. DB:errmsg())\n    end\n  end\n\n  function sql.getBalance(processId)\n    local stmt = DB:prepare [[\n    SELECT * FROM subscribers WHERE process_id = :process_id\n  ]]\n    if not stmt then\n      error(\"Failed to prepare SQL statement for getting balance entry: \" .. DB:errmsg())\n    end\n    stmt:bind_names({ process_id = processId })\n    local row = sql.queryOne(stmt)\n    return row and row.balance or \"0\"\n  end\n\n  -- SUBSCRIPTION\n\n  function sql.subscribeToTopics(processId, topics)\n    -- add the topics to the existing topics while avoiding duplicates\n    local stmt = DB:prepare [[\n    UPDATE subscribers\n    SET topics = (\n        SELECT json_group_array(topic)\n        FROM (\n            SELECT json_each.value as topic\n            FROM subscribers, json_each(subscribers.topics)\n            WHERE process_id = :process_id\n\n            UNION\n\n            SELECT json_each.value as topic\n            FROM json_each(:topics)\n        )\n    )\n    WHERE process_id = :process_id;\n  ]]\n    if not stmt then\n      error(\"Failed to prepare SQL statement for subscribing to topics: \" .. DB:errmsg())\n    end\n    stmt:bind_names({\n      process_id = processId,\n      topic = topics\n    })\n    local _, err = stmt:step()\n    stmt:finalize()\n    if err then\n      error(\"Err: \" .. DB:errmsg())\n    end\n  end\n\n  function sql.unsubscribeFromTopics(processId, topics)\n    -- remove the topics from the existing topics\n    local stmt = DB:prepare [[\n    UPDATE subscribers\n    SET topics = (\n        SELECT json_group_array(topic)\n        FROM (\n            SELECT json_each.value as topic\n            FROM subscribers, json_each(subscribers.topics)\n            WHERE process_id = :process_id\n\n            EXCEPT\n\n            SELECT json_each.value as topic\n            FROM json_each(:topics)\n        )\n    )\n    WHERE process_id = :process_id;\n  ]]\n    if not stmt then\n      error(\"Failed to prepare SQL statement for unsubscribing from topics: \" .. DB:errmsg())\n    end\n    stmt:bind_names({\n      process_id = processId,\n      topic = topics\n    })\n    local _, err = stmt:step()\n    stmt:finalize()\n    if err then\n      error(\"Err: \" .. DB:errmsg())\n    end\n  end\n\n  -- NOTIFICATIONS\n\n  function mod.activationCondition()\n    return [[\n    (subs.whitelisted = 1 OR subs.balance <> \"0\")\n  ]]\n  end\n\n  function sql.getTargetsForTopic(topic)\n    local activationCondition = mod.activationCondition()\n    local stmt = DB:prepare [[\n    SELECT process_id\n    FROM subscribers as subs\n    WHERE json_contains(topics, :topic) AND ]] .. activationCondition\n\n    if not stmt then\n      error(\"Failed to prepare SQL statement for getting notifiable subscribers: \" .. DB:errmsg())\n    end\n    stmt:bind_names({ topic = topic })\n    return sql.queryMany(stmt)\n  end\n\n  -- UTILS\n\n  function sql.queryMany(stmt)\n    local rows = {}\n    for row in stmt:nrows() do\n      table.insert(rows, row)\n    end\n    stmt:reset()\n    return rows\n  end\n\n  function sql.queryOne(stmt)\n    return sql.queryMany(stmt)[1]\n  end\n\n  function sql.rawQuery(query)\n    local stmt = DB:prepare(query)\n    if not stmt then\n      error(\"Err: \" .. DB:errmsg())\n    end\n    return sql.queryMany(stmt)\n  end\n\n  return sql\nend\n\nreturn newmodule\nend\nend\n\ndo\nlocal _ENV = _ENV\npackage.preload[ \"storage-vanilla\" ] = function( ... ) local arg = _G.arg;\nlocal bint = require \".bint\" (256)\nlocal json = require \"json\"\nlocal utils = require \".utils\"\n\nlocal function newmodule(pkg)\n  local mod = {\n    Subscribers = pkg._storage and pkg._storage.Subscribers or {} -- we preserve state from previously used package\n  }\n\n  --[[\n    mod.Subscribers :\n    {\n      processId: ID = {\n        topics: string, -- JSON (string representation of a string[])\n        balance: string,\n        whitelisted: number -- 0 or 1 -- if 1, receives data without the need to pay\n      }\n    }\n  ]]\n\n  pkg._storage = mod\n\n  -- REGISTRATION & BALANCES\n\n  function mod.registerSubscriber(processId, whitelisted)\n    mod.Subscribers[processId] = mod.Subscribers[processId] or {\n      balance = \"0\",\n      topics = json.encode({}),\n      whitelisted = whitelisted and 1 or 0,\n    }\n  end\n\n  function mod.getSubscriber(processId)\n    local data = json.decode(json.encode(mod.Subscribers[processId]))\n    if data then\n      data.whitelisted = data.whitelisted == 1\n      data.topics = json.decode(data.topics)\n    end\n    return data\n  end\n\n  function mod.updateBalance(processId, amount, isCredit)\n    local current = bint(mod.Subscribers[processId].balance)\n    local diff = isCredit and bint(amount) or -bint(amount)\n    mod.Subscribers[processId].balance = tostring(current + diff)\n  end\n\n  -- SUBSCRIPTIONS\n\n  function mod.subscribeToTopics(processId, topics)\n    local existingTopics = json.decode(mod.Subscribers[processId].topics)\n\n    for _, topic in ipairs(topics) do\n      if not utils.includes(topic, existingTopics) then\n        table.insert(existingTopics, topic)\n      end\n    end\n    mod.Subscribers[processId].topics = json.encode(existingTopics)\n  end\n\n  function mod.unsubscribeFromTopics(processId, topics)\n    local existingTopics = json.decode(mod.Subscribers[processId].topics)\n    for _, topic in ipairs(topics) do\n      existingTopics = utils.filter(\n        function(t)\n          return t ~= topic\n        end,\n        existingTopics\n      )\n    end\n    mod.Subscribers[processId].topics = json.encode(existingTopics)\n  end\n\n  -- NOTIFICATIONS\n\n  function mod.getTargetsForTopic(topic)\n    local targets = {}\n    for processId, v in pairs(mod.Subscribers) do\n      local mayReceiveNotification = mod.hasEnoughBalance(processId) or v.whitelisted == 1\n      if mod.isSubscribedTo(processId, topic) and mayReceiveNotification then\n        table.insert(targets, processId)\n      end\n    end\n    return targets\n  end\n\n  -- HELPERS\n\n  mod.hasEnoughBalance = function(processId)\n    return mod.Subscribers[processId] and bint(mod.Subscribers[processId].balance) > 0\n  end\n\n  mod.isSubscribedTo = function(processId, topic)\n    local subscription = mod.Subscribers[processId]\n    if not subscription then return false end\n\n    local topics = json.decode(subscription.topics)\n    for _, subscribedTopic in ipairs(topics) do\n      if subscribedTopic == topic then\n        return true\n      end\n    end\n    return false\n  end\nend\n\nreturn newmodule\nend\nend\n\nlocal function newmodule(cfg)\n  local isInitial = Subscribable == nil\n\n  -- for bug-prevention, force the package user to be explicit on initial require\n  assert(not isInitial or cfg and cfg.useDB ~= nil,\n    \"cfg.useDb is required: are you using the sqlite version (true) or the Lua-table based version (false)?\")\n\n  local pkg = Subscribable or\n      { useDB = cfg.useDB } -- useDB can only be set on initialization; afterwards it remains the same\n\n  pkg.version = '1.3.8'\n\n  -- pkg acts like the package \"global\", bundling the state and API functions of the package\n\n  if pkg.useDB then\n    require \"storage-db\" (pkg)\n  else\n    require \"storage-vanilla\" (pkg)\n  end\n\n  require \"pkg-api\" (pkg)\n\n  Handlers.add(\n    \"subscribable.Register-Subscriber\",\n    Handlers.utils.hasMatchingTag(\"Action\", \"Register-Subscriber\"),\n    pkg.handleRegisterSubscriber\n  )\n\n  Handlers.add(\n    'subscribable.Get-Subscriber',\n    Handlers.utils.hasMatchingTag('Action', 'Get-Subscriber'),\n    pkg.handleGetSubscriber\n  )\n\n  Handlers.add(\n    \"subscribable.Receive-Payment\",\n    function(msg)\n      return Handlers.utils.hasMatchingTag(\"Action\", \"Credit-Notice\")(msg)\n          and Handlers.utils.hasMatchingTag(\"X-Action\", \"Pay-For-Subscription\")(msg)\n    end,\n    pkg.handleReceivePayment\n  )\n\n  Handlers.add(\n    'subscribable.Subscribe-To-Topics',\n    Handlers.utils.hasMatchingTag('Action', 'Subscribe-To-Topics'),\n    pkg.handleSubscribeToTopics\n  )\n\n  Handlers.add(\n    'subscribable.Unsubscribe-From-Topics',\n    Handlers.utils.hasMatchingTag('Action', 'Unsubscribe-From-Topics'),\n    pkg.handleUnsubscribeFromTopics\n  )\n\n  return pkg\nend\nreturn newmodule\n",
    "PkgID": "x1PE7TlYt2YTc2ldzXdJG_P5Yt2Y-KfKdbe9FIZCEfI",
    "Description": "Base package for an AO process with subscription abilities (manage subscriptions, notify subscribers on topics)",
    "Installs": 2,
    "Keywords": [],
    "Warnings": {},
    "License": "",
    "Dependencies": {},
    "Vendor": "@autonomousfinance",
    "Readme": "# subscribable\n\n## Subscription provider capabilities for an AO process\n\nThis package facilitates the development of AO processes that require the ability to register subscribers for events concerning specific topics. It effectively means that messages will be dispatched to subscribers whenever the topic-related events occur.\n\nThe package comes in two flavours:\n\n1. The **vanilla** version is based on **simple Lua tables**.\n2. The **DB** version is based on **sqlite3**, which is natively available on AO.\n\n## Features\n\n### Handlers\n\n1. register subscriber\n2. receive payment for (spam-protection / monetization) - a specific token needs to be configured\n3. get available topics\n4. subscribe/unsubscribe a registered subscriber w/ specific topics\n5. get subscriber data\n\n### API\n\n1. configure topics w/ corresponding checks\n2. functions to implement the above Handlers or your own variations\n3. ability to register a process as whitelisted (gated to the process' `Owner`)\n4. notify subscribers to given topics\n5. notify subscribers to given topics with checks\n6. configure the payment token (gated to the process' `Owner`)\n\n## Usage\n\nThis package can be used via APM installation through `aos` or via a pre-build APM download into your project directory.\n\n### APM download & require locally\n\nInstall `apm-tool` on your system. This cli tool allows you to download APM packages into your lua project.\n\n```shell\nnpm i -g apm-tool\n```\n\nDownlad the package into your project as a single lua file:\n\n```shell\ncd your/project/directory\napm-tool download ownable-multi\ncp apm_modules/@autonomousfinance/ownable-multi/main.lua ./ownable-multi.lua\n```\n\nRequire the file locally from your main process lua file. \n\n```lua\nOwnable = require(\"subscribable\") ({\n  useDB = false -- using the vanilla flavour\n})\n```\n\nThe code in `example.lua` and `example-db.lua` demonstrates how to achieve this. \n\n📝 Keep in mind, with this approach you will eventually need to amalgamate your multiple lua files into a single lua file build that can be `.load`ed into your process via AOS. See `package/subscribable/build.sh` for an example of how to achieve this.\n\n### APM install & require from APM\n\nConnect with your process via `aos`. Perform the **steps 1 & 2 from your AOS client terminal**.\n\n1. Install APM in your process\n\n```lua\n.load client-tool.lua\n```\n\n2. Install this package via APM\n\n```lua\nAPM.install('@autonomousfinance/subscribable')\n```\n\n3. Require this package in your Lua script. The resulting table contains the package API. The `require` statement also adds package-specific handlers into the `_G.Handlers.list` of your process.\n\n```lua\nSubscribable = require \"@autonomousfinance/subscribable\" ({\n  useDB = false -- using the vanilla flavour\n})\n```\n\n### After requiring\n\nAfter the package is required into your main process, you have\n\n1. additional handlers added to Handlers.list\n2. the ability to use the `subscribable` API\n\n```lua\nSubscribable.configTopicsAndChecks()\n\nSubscribable.checkNotifyTopic()\n\nSubscribable.checkNotifyTopics()\n\nSubscribable.getRegisteredSubscriber()\n```\n\nExecute `.configTopicsAndChecks()` to configure the supported topics and corresponding checks. You can repeat this in the future as needed.\n\nIn your process handlers, wherever topic-relevant state changes have occurred, you can execute `.notifyTopic()` or `.checkNotifyTopic()` to dispatch notifications to subscribers.\n\nHere is a simple example\n\n```lua\nCounter = Counter or 0\n\n-- configure topic\nSubscribable.configTopicsAndChecks({\n  'even-counter',       -- topic name\n  function()            -- a check function to determine if the event of the occurs & generate a notification payload\n    if Counter % 2 == 0 then return true, {counter = Counter} end\n    return false\n  end\n})\n\n-- Updates to Counter\nHandlers.add(\n  'increment',\n  Handlers.utils.hasMatchingTag(\"Action\", \"Increment\"),\n  function()\n    -- state change\n    Counter = Counter + 1\n    -- notifications\n    sub.checkNotifyTopic('even-counter') -- sends out notifications based on check and payload from the topic event check function you configured\n  end\n)\n```\n\n### Explicit vs. Fully Automated\n\nFor the sake of computational efficiency, we opted **against fully automated subscriber notifications**.\n\nIt would have been possible to design the package such that *any state change* results in a check for topic events and then proceeds to notify all subscribers. \n\nIn contrast, `subscribable` gives you a framework to easily **configure** your custom topic event checks, in that you define\n\n1. what topics are supported\n2. how the process state is checked to determine occurrence of a specific topic event\n\nafter which **you decide** where in your process handlers you want to perform checks for any given topic event. \n\nWith the existing topic event checks being configured beforehand, your decision is coded declaratively - you can either \n\n1. `.checkNotifyTopic(<some_topic>)` - this checks for `<some_topic>` as configured by you. If positive, subscribers are then notified.\n2. `.notifyTopic(<some_topic>)` - this notifies subscribers to `<some_topic>` without a check\n\nWith this approach you have more control over the occurrence of computation related to topic event checks and notification sending.\n\nThat being said, `subscribable` is designed to allow you to easily implement a **fully automated mechanism on top** of it, in your process which uses the package.\n\n\n### Minimal global state pollution\n\nThe package affects nothing in the global space of your project, except for the `_G.Handlers.list` and `_G.DB` (if you opt for the *DB* flavour). The state needed for subscribable capabilities is **encapsulated in the package module**.\n\nWhen opting for the *DB* flavour you'll probably be using sqlite in your own application code. For an efficient and yet convenient usage, this package makes `DB = sqlite3.open_memory()` a global singleton so that you wouldn't have to access it via the required package. Please keep in mind that this assignment only occurs once you require `subscribable` into your process.\n\nFor upgradability we recommend assigning the required package to a global variable of your process (see below).\n\n## Upgrading your process\n\nYou may want your AO process to be upgradable, which includes the ability to upgrade this package as it is used by your process. \n\nIn order to make this possible, this package gives you the option to `require` it as an upgrade.\n```lua\nSubscribable = require \"@autonomousfinance/subscribable\"()  -- or require \"<your-local-path>/subscribable\", as explained above\n```\nWhen doing that, the internal package state your process has been using so far (i.e. the subscribers and topics configuration), will be \"adopted\" by the new version of package. This only works **if you are using `Subscribable` as the name** for the global variable of the required package in your process.\n\nExamples of this can be found in `example/example.lua` and `example/example-db.lua`.\n\n❗️ The configuration for vanilla or db can only be used when you first require the package. Upgrades will not allow you to change flavour.\n\n## Overriding Functionality\n\nSimilarly to extending a smart contract in Solidity, using this package allows builders to change the default functionality as needed.\n\n### 1. You can override handlers added by this package\n\nEither replace the handler entirely\n```lua\nHandlers.add(\n  'subscribable.Register-Subscriber',\n  -- your custom matcher,\n  -- your custom handle function\n)\n```\n\nor override handleFunctions\n```lua\n-- handle for \"ownable-multi.Register-Subscriber\"\nfunction(msg)\n  -- ADDITIONAL condition\n  assert(isChristmasEve(msg.Timestamp))\n  -- same as before\n  Subscribable.handleRegisterSubscriber\nend\n```\n\n### 2. You can override more specific API functions of this package\n\n```lua\nlocal originalRegisterSubscriber = Subscribable.registerSubscriber\nSubscribable.registerSubscriber = function(processId, whitelisted)\n  -- same as before\n  originalRegisterSubscriber(processId, whitelisted)\n  -- your ADDITIONAL logic\n  ao.send({Target = AGGREGATOR_PROCESS, Action = \"Subscriber-Registered\", [\"Process-ID\"] = processId})\nend\n```\n\n### 3. You can create new Handlers with available API functions of this package\n\n```lua\nHandlers.add(\n  \"Register-Whitelisted-Subscriber\",\n  Handlers.utils.hasMatchingTag(\"Action\", \"Register-Whitelisted-Subscriber\"),\n  Subscribable.handleRegisterWhitelistedSubscriber\n)\n```\n\n### Consider Access Control\n\nSome API functions like `handleSetPaymentToken` and `handleRegisterWhitelistedSubscriber` are gated - they **restrict access** to the current `Owner` of the process, or the process itself. In order to give your process \"Ownable\" capabilities (managing ownership), consider using [ownable](https://github.com/Autonomous-Finance/aos-packages/tree/main/packages/ownable) or [ownable-multi](https://github.com/Autonomous-Finance/aos-packages/tree/main/packages/ownable-multi).\n\n\n## Subscription Model\n\n1. Subscription clients subscribe and unsubscribe **themselves**\n2. Subscriptions are not active by default. In the current implementation, their activation requires one of these conditions\n   1. the client is registered as **whitelisted** (by you, the owner of the subscription server); this works well for partnerships\n   2. the server receives is a **subscription payment** associated with the client; this can be refined to suit your business needs\n\n### Whitelisting \nThe current implementation includes a function `pkg.handleRegisterWhitelistedSubscriber(msg)`, but it is not exposed in a handler. You can do so if you need to\n\n### Payments\nSusbcriptions can be **paid for by anyone**, the reference being the **process id** of the subscriber (client).\n\nThe current implementation has a simple activation criteria: it only checks for the balance to be non-zero.\n\nTo customize this, you can override the relevant API function\n- VANILLA VERSION: override `pkg.hasEnoughBalance(processId)` -> see `src/storage-vanilla.lua` for reference\n- DB VERSION: override `pgk._store.getTargetsForTopic(topic)` -> see `src/storage-db.lua` for reference\n\nYou can find an example on how to override an API function in a section [above](#2-you-can-override-more-specific-api-functions-of-this-package).\n\n### Example \n\nIf you are using this package to become a **subscription server**, here is how another process would become your **client** (subscribe to you).\n\n```lua\n-- subscriber-process.lua\n\nSUBSCRIPTION_SERVER = '...' -- your process id\nSUBCSCRIPTION_PAYMENT_TOKEN  = '...' -- whatever you, as a subscription server, set as your pkg.PAYMENT_TOKEN\nSUBSCRIPTION_PAYMENT_AMOUNT = '...' -- currently not checked by the package. there just has to be a positive balance in given token\n\n-- subscription\nao.send({\n  Target = SUBSCRIPTION_SERVER,\n  Action = 'Register-Subscriber',\n  Topics = json.encode(['latest-price'])\n})\n```\n\nAnd here is how anyone could **activate the subscription** by paying for it. We demonstrate how the client itself would do it\n\n```lua\nao.send({\n  Target = SUBSCRIPTION_PAYMENT_TOKEN,\n  Action = 'Transfer',\n  Recipient = SUBSCRIPTION_SERVER,\n  Quantity = SUBSCRIPTION_PAYMENT_AMOUNT,\n  [\"X-Action\"] = \"Pay-For-Subscription\",\n  [\"X-Subscriber-Process-Id\"] = ao.id -- the client process ID; this allows your process to associate the incoming payment with the particular subscriber ID\n})\n```\n\n## Conflict Considerations\n\n⚠️ ❗️ If overriding functionality is not something you need, be mindful of potential conflicts in terms of the **`Handlers.list`**\n\nBoth your application code and other packages you install via APM, can potentially conflict with this package. Consider the following handlers as reserved by this package.\n\n```lua\n\nHandlers.list = {\n  -- ...\n  { \n    name = \"subscribable.Register-Subscriber\",\n    -- ... \n  },\n  { \n    name = \"subscribable.Get-Subscriber\",\n    -- ... \n  },\n  { \n    name = \"subscribable.Receive-Payment\",\n    -- ... \n  },\n  { \n    name = \"subscribable.Get-Available-Topics\",\n    -- ... \n  },\n  { \n    name = \"subscribable.Subscribe-To-Topics\",\n    -- ... \n  },\n  { \n    name = \"subscribable.Unsubscribe-From-Topics\",\n    -- ... \n  }\n  -- ...\n}\n```\n\n## Persistence: Vanilla vs DB\n\nThe vanilla flavour uses simple lua tables to persist balances and subscriptions.\n\nThe DB flavour is highly scalable, suitable for processes with many subscribers. The downside there is some additional logical complexity and more verbose code, especially when extending the basic functionality.\n\nWe've built this non-sql flavour for the purpose of developer convenience, for cases where it would be scalable enough.\n\n\n\n## TODO\n\n### docs\n- Topics README section: how are they built/defined? parameters\n\n\n### functionality \n- topics w/ parameter for lambda\n\n- termination of a subscription\n\n- remove subscriber\n\n\n- data validation -> multiple topics passed in on registration / on subscription / on unsubscription\n\n- (v2) balance subtraction \"pay as you go\", since we don't use cron and can't as easily predict outcomes",
    "Version": "1.3.8",
    "ID": 69,
    "Timestamp": 1725611081539
}